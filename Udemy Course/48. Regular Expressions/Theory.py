# Regular expressions - регулярные выражения (шаблонные выражения) - специальная командная последовательность, которая задает параметры поиска подстрок данных в тексте

# Якоря
# ^             Обозначает начало строки, то есть поиск только в начале
# $             Обозначает конец строки, то есть поиск только в конце строки

# Границы слов
# \b            Обозначает начало слова, если стоит в начале, или конец, если стоит в конце 

# Логика
# |             Обозначает логическое выражение ИЛИ, то есть один ИЛИ второй вариант регулярного выражения

# Множества и диапазоны
# [...]         Обозначает множество символов, в том сисле любой символ из скобок   [.,!?-]         - выбор любого из этих символов. 
#                                                                                   [0123456789]    - любая цифра, также работает указание [0-9]
#                                                                                   [A-Za-z]        - любая строчная или заглавная латинская буква     
#                                                                                   [0-9A-Z!#]      - любая цифра или заглавная латинская буква, а также символы !# 

# Отрицания
# [^...]	    Любой символ, кроме перечисленных

# Шаблоны
# \d	        Любая цифра
# \D	        Любой символ, кроме цифры
# \w	        Любой алфавитно-цифровой символ и _
# \W	        Любая не-буква, не-цифра и не подчёркивание	
# \s	        Любой пробельный символ (пробел, табуляция, конец строки и т.п.)
# \S	        Любой непробельный символ	
# .	            Один любой символ, кроме новой строки \n
# [abc-], [-1]	Eсли нужен минус, его нужно указать последним или первым		

# \B	Не граница слова: либо и слева, и справа буквы, либо и слева, и справа НЕ буквы	

# Квантификаторы
# +	            Одно или более, синоним {1,}
# *	            Ноль или более, синоним {0,}
# ?	            От 0 до 1 цифры, синоним {0,1}  
# {n}	Ровно n повторений	\d{4}	1, 12, 123, 1234, 12345
# {m,n}	От m до n повторений включительно	\d{2,4}	1, 12, 123, 1234, 12345
# {m,}	Не менее m повторений	\d{3,}	1, 12, 123, 1234, 12345
# {,n}	Не более n повторений	\d{,2}	1, 12, 123

# Экранирование
# \         Экранирование служит для отдельного указания специальных символов или отделения выражения. Примеры:
#                                                                                                      \+|\-?\b+ - символ + или символ - с количеством числе от 1 до ∞

# Группы
# ( (...) (...) (...) ) - пример группы регулярных выражений. Группы имеют нумерацию, в данном примере от 0 до 3, само общее выражение имеет группу 0, остальные - по порядку 
# Пример: (http|https)(://)([a-zA-Z0-9.-_]\.(ru|com|cc))
# Группе можно назначить имя или номер, по принципу:
# \n или $n - указание номера группы, где n - сам номер
# https://(msi)\.\1=store.com   будет соответсвовать https://msi.msi-shop.com - где \1 - это повторение запроса первой группы
# (.*?)         группа для выбора всего доступного текста 

# Жадные или ленивые последовательности:
# По умолчанию квантификаторы жадные — захватывают максимально возможное число символов. 
# Добавление ? делает их ленивыми, они захватывают минимально возможное число символов

# (.+) или (.*)     Жадные - нацелены на поиск до последнего вхождения
# (.+?) или (.*?)   Ленивые - нацелены на поиск до первого вхождения

# Пример:
# <.*>      <a href='https://www.youtube.com/'>youtube</a>      <.*?> - выделение всех символов внутри угловых скобок в обоих вариантах жадного и ленивого поиска
# <a href='https://www.youtube.com/'>youtube</a>                <a href='https://www.youtube.com/'></a> - жадный выделяет все внутри скобок, игнируя закрытие первой скобки
#                                                                                                         ленивый поиск выделяет обе скобки, учитывая закрытие первой

# Опережающие или ретроспективные проверки:
# Х(?=Y)    Позитивная опережающая      Найти Х если за ним следует Y
# Х(?|Y)    Негативная опережающая      Найти Х если за ним НЕ следует Y
# Х(?<=Y)   Позитивная ретроспективная  Найти Х если перед ним стоит Y
# Х(?<!Y)   Негативная ретроспективная  Найти Х если перед ним НЕ стоит Y
# Пример:   \d+(?=\$)   - означает найти ЛЮБОЕ ЧИСЛО, если за ним идет символ $

# Синтаксис
import re 
string1 = 'Name: Drew. Birthdate: 30 September, 1999'
# re.search(pattern, string)	            Найти в строке string первую строчку, подходящую под шаблон pattern;
reg = r"Name: ([a-zA-Z]+)\. Birthdate: (\d+) ([a-zA-Z]+), (\d+)" # Поиск в строке данных, соответсвующих имени и дате рождения
match =  re.search (reg, string1)
if match != None:
    print ('Вся совпавшая строка:', match.group(0))
    print ('Группа 1:', match.group(1))
    print ('Группа 2:', match.group(2))
    print ('Группа 2:', match.group(3))

# re.fullmatch(pattern, string)	            Проверить, подходит ли строка string под шаблон pattern;
string2 = 'my_1password2!pass'
reg = r"^[a-zA-Z0-9_\-!?]{8,18}$"
match = re.match(reg, string2)
if match:
    print('Пароль подойдет')
else:
    print('Пароль не подойдет')

# re.sub(pattern, replacement, string, count=0)    Заменить в строке string все непересекающиеся шаблоны pattern на repl;
string3 = '''
Тридцать три коровы,
Тридцать три коровы,
Тридцать три коровы -
Свежая строка.
Тридцать три коровы,
Стих родился новый,
Как стакан парного молока.
'''
reg = r"Тридцать три"
replacement = '33'
newstring = re.sub(reg, replacement, string3, count=4)
print (newstring)

# re.split(pattern, string, maxsplit=0)	    Аналог str.split(), только разделение происходит по подстрокам, подходящим под шаблон pattern;
string4 = 'Лопушистый, Облучок, Оклеить, Окрасочный, Перестраивать'
splittedstring = re.split(r",", string4)
print (splittedstring)

# re.findall(pattern, string)	            Найти в строке string все непересекающиеся шаблоны pattern и вернуть списком;
string5 = '''
<div>
    <h1>Hi</h1>
    <h3>Pair checking</h3>
    <p> In this example, we'll ise the follower helping function to display match objects a little more gracefully </p>
</div>
'''
reg = r"<([a-zA-Z0-9]+)>"
newstring = re.findall(reg, string5)
print ('Указанные теги: ',newstring)

# re.finditer(pattern, string)	            Итератор по всем непересекающимся шаблонам pattern в строке string (выдаются match-объекты);
string6 = '''
<h3>Navigational_panel</h3>
    <ul>
        <li class="right" style="margin-right: 10px">
        <a href="aindex.html" title="AIndex">AIndex</a></li>
        <li class="right">
        <a href="bindex.html" title="BIndex">BIndex</a</li>
        <li class="right">
        <a href="cindex.html" title="CIndex">CIndex</a</li>
        <li class="right">
        <a href="dindex.html" title="DIndex">DIndex</a</li>
        <li>
        <img src="../image.png" title="Image">
        </li>
        <li><a href="https://www.image.com">Image</li>
    </ul>
'''
print ('Ссылки:')
newstring = re.finditer(r'<a href="(.*?)">', string6)
for item in newstring:
    print (item.group(0))

# re.compile(pattern, flags=0)              Компилирует регулярное выражение в объект, к которому можно применять методы regEx
print ('Compile')
expression = re.compile ('[0-9]+')
print (expression.findall('I was born at 10 p.m. on 18th July 1998'))

# Additional flags 
# Константа	        Её смысл
# re.ASCII	          По умолчанию \w, \W, \b, \B, \d, \D, \s, \S соответствуют
#                     все юникодные символы с соответствующим качеством.
#                     Например, \d соответствуют не только арабские цифры,
#                     но и вот такие: ٠١٢٣٤٥٦٧٨٩.
#                     re.ASCII ускоряет работу,
#                     если все соответствия лежат внутри ASCII.

# re.IGNORECASE	      Не различать заглавные и маленькие буквы.
#                     Работает медленнее, но иногда удобно

# re.MULTILINE	      Специальные символы ^ и $ соответствуют
#                     началу и концу каждой строки

# re.DOTALL	          По умолчанию символ \n конца строки не подходит под точку.
#                     С этим флагом точка — вообще любой символ

# https://regexr.com/