# Regular expressions - регулярные выражения (шаблонные выражения) - специальная командная последовательность, которая задает параметры поиска подстрок данных в тексте, 
# является регистрозависимой и пишется в виде синтаксиса:
import re 
    # re.search(pattern, string)	            Найти в строке string первую строчку, подходящую под шаблон pattern;
    # re.fullmatch(pattern, string)	            Проверить, подходит ли строка string под шаблон pattern;
    # re.split(pattern, string, maxsplit=0)	    Аналог str.split(), только разделение происходит по подстрокам, подходящим под шаблон pattern;
    # re.findall(pattern, string)	            Найти в строке string все непересекающиеся шаблоны pattern;
    # re.finditer(pattern, string)	            Итератор по всем непересекающимся шаблонам pattern в строке string (выдаются match-объекты);
    # re.sub(pattern, repl, string, count=0)    Заменить в строке string все непересекающиеся шаблоны pattern на repl;

# Шаблоны
# .	            Один любой символ, кроме новой строки \n
# \d	        Любая цифра
# \D	        Любой символ, кроме цифры
# \s	        Любой пробельный символ (пробел, табуляция, конец строки и т.п.)
# \S	        Любой непробельный символ	
# \w	        Любая буква (то, что может быть частью слова), а также цифры и _
# \W	        Любая не-буква, не-цифра и не подчёркивание	
# [..]          Один из символов в скобках, а также любой символ из диапазона a-b
# [^..]	        Любой символ, кроме перечисленных	<[^>]>	<1>, <a>, <>>
# [abc-], [-1]	если нужен минус, его нужно указать последним или первым			

# \b	Начало или конец слова (слева пусто или не-буква, справа буква и наоборот).
#       В отличие от предыдущих соответствует позиции, а не символу

# \B	Не граница слова: либо и слева, и справа буквы, либо и слева, и справа НЕ буквы

# \d≈[0-9],
# \D≈[^0-9],
# \w≈[0-9a-zA-Z
# а-яА-ЯёЁ],
# \s≈[ \f\n\r\t\v]	Буква “ё” не включается в общий диапазон букв!

# Квантификаторы
# {n}	Ровно n повторений	\d{4}	1, 12, 123, 1234, 12345
# {m,n}	От m до n повторений включительно	\d{2,4}	1, 12, 123, 1234, 12345
# {m,}	Не менее m повторений	\d{3,}	1, 12, 123, 1234, 12345
# {,n}	Не более n повторений	\d{,2}	1, 12, 123
# ?	Ноль или одно вхождение, синоним {0,1}	валы?	вал, валы, валов
# *	Ноль или более, синоним {0,}	СУ\d*	СУ, СУ1, СУ12, ...
# +	Одно или более, синоним {1,}	a\)+	a), a)), a))), ba)])

# *?        По умолчанию квантификаторы жадные —
# +?        захватывают максимально возможное число символов.
# ??        Добавление ? делает их ленивыми,
# {m,n}?    они захватывают минимально возможное число символов
# {,n}?
# {m,}?

# Additional flags 

# Константа	        Её смысл
# re.ASCII	        По умолчанию \w, \W, \b, \B, \d, \D, \s, \S соответствуют
#                     все юникодные символы с соответствующим качеством.
#                     Например, \d соответствуют не только арабские цифры,
#                     но и вот такие: ٠١٢٣٤٥٦٧٨٩.
#                     re.ASCII ускоряет работу,
#                     если все соответствия лежат внутри ASCII.

# re.IGNORECASE	    Не различать заглавные и маленькие буквы.
#                     Работает медленнее, но иногда удобно

# re.MULTILINE	    Специальные символы ^ и $ соответствуют
#                     началу и концу каждой строки

# re.DOTALL	        По умолчанию символ \n конца строки не подходит под точку.
#                     С этим флагом точка — вообще любой символ

import re 

match = re.search(r'\d\d\D\d\d', r'Телефон 123-12-12') 
print(match[0] if match else 'Not found') 
# -> 23-12 
match = re.search(r'\d\d\D\d\d', r'Телефон 1231212') 
print(match[0] if match else 'Not found') 
# -> Not found 

match = re.fullmatch(r'\d\d\D\d\d', r'12-12') 
print('YES' if match else 'NO') 
# -> YES 
match = re.fullmatch(r'\d\d\D\d\d', r'Т. 12-12') 
print('YES' if match else 'NO') 
# -> NO 

print(re.split(r'\W+', 'Где, скажите мне, мои очки??!')) 
# -> ['Где', 'скажите', 'мне', 'мои', 'очки', ''] 

print(re.findall(r'\d\d\.\d\d\.\d{4}', 
                 r'Эта строка написана 19.01.2018, а могла бы и 01.09.2017')) 
# -> ['19.01.2018', '01.09.2017'] 

for m in re.finditer(r'\d\d\.\d\d\.\d{4}', r'Эта строка написана 19.01.2018, а могла бы и 01.09.2017'): 
    print('Дата', m[0], 'начинается с позиции', m.start()) 
# -> Дата 19.01.2018 начинается с позиции 20 
# -> Дата 01.09.2017 начинается с позиции 45 

print(re.sub(r'\d\d\.\d\d\.\d{4}', 
             r'DD.MM.YYYY', 
             r'Эта строка написана 19.01.2018, а могла бы и 01.09.2017')) 
# -> Эта строка написана DD.MM.YYYY, а могла бы и DD.MM.YYYY 


# https://habr.com/ru/articles/349860/#Primery_regulyarnyh_vyrazheniy