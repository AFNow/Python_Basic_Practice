lst1 = [1,2,3,4,5] # Для обычных объектов Python применяются как и ранее операции по типу проверки длины или итераций,
print (len (lst1)) # но для назначенных классами объектов такое не работает и вызывает ошибку, object of type 'Sample' has no len()

class Sample(): # Пустой класс для примера
    pass

mysample = Sample() # Назначения объекта как класс
# print (len(mysample)) 
# При попытке напечатать или запросить длину объекта, будет выдаваться ошибка, так как классовый тип данных подразумевает другой метод.

class Book(): # Созданный класс "Книга" содержит два строковых и один числовой параметры
    def __init__(self, title, author, pages):
        self.title = title
        self.author = author
        self.pages = pages

    def __str__(self): # Cпециальная операция __str__ возвращает текстовое содержание, отформатированное по образу в операции
        return f"{self.author}: {self.title}"
    
    #def __len__(self): # В данном случае имело бы смысл использовать стандартное назначение оператора len(), но также имеет смысл следующего примера
    #    return len(self.pages)
    
    def __len__(self): # который описывает длину книги, которая указана в переменной book
        return self.pages
    
    def __del__(self): # специальная операция __del__ предназначена для ручного перемещения данных в деструктор, но для этого требуется отсутствие обращений к данным
        return ('Книга удалена')
book = Book ('Идиот','Федор Михайлович Достоевкий',640)

print (book)

print (len(book),'страниц') # Таким образом встроенный оператор len() заимел свои новые функции и вместо количества ячеек индекса теперь указывает длину книги.